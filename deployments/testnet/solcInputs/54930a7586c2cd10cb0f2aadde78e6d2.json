{
  "language": "Solidity",
  "sources": {
    "contracts/access/Ownable.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../utils/Context.sol\";\n\nabstract contract Ownable is Context {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  constructor() {\n    address msgSender = _msgSender();\n    _owner = msgSender;\n    emit OwnershipTransferred(address(0), msgSender);\n  }\n\n  function owner() public view virtual returns (address) {\n    return _owner;\n  }\n\n  modifier onlyOwner() {\n    require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    _;\n  }\n\n  function renounceOwnership() public virtual onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  function transferOwnership(address newOwner) public virtual onlyOwner {\n    require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"
    },
    "contracts/utils/Context.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address payable) {\n    return payable(msg.sender);\n  }\n\n  function _msgData() internal view virtual returns (bytes memory) {\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n    return msg.data;\n  }\n}\n"
    },
    "contracts/LunaMoon.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"./ERC20/ERC20.sol\";\nimport \"./access/Ownable.sol\";\nimport \"./math/SafeMath.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\nimport \"./LunaDividendTracker.sol\";\nimport \"./uniswap/IUniswapV2Pair.sol\";\nimport \"./uniswap/IUniswapV2Factory.sol\";\n\ncontract LunaMoon is ERC20, Ownable {\n  //library\n  using SafeMath for uint256;\n  //custom\n  IUniswapV2Router02 public uniswapV2Router;\n  _LUNADividendTracker public _lunaDividendTracker;\n  //address\n  address public uniswapV2Pair;\n  address public marketingWallet = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266; // development wallet\n  address public lunaBurnWallet = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266; // development wallet\n  address public liqWallet = 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266; // development wallet\n  address public _lunaDividendToken;\n  address public deadWallet = 0x000000000000000000000000000000000000dEaD;\n  address public lunaAddress = 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0; // Node: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0 LUNA Wormhole: 0x156ab3346823B651294766e23e6Cf87254d68962\n  //bool\n  bool public marketingSwapSendActive = true;\n  bool public lunaBurnSwapSendActive = true;\n  bool public LiqSwapSendActive = true;\n  bool public swapAndLiquifyEnabled = true;\n  bool public ProcessDividendStatus = true;\n  bool public _lunaDividendEnabled = true;\n  bool public marketActive;\n  bool public blockMultiBuys = true;\n  bool public limitSells = true;\n  bool public limitBuys = true;\n  bool public feeStatus = true;\n  bool public buyFeeStatus = true;\n  bool public sellFeeStatus = true;\n  bool public maxWallet = true;\n  bool private isInternalTransaction;\n\n  //uint\n  uint256 public buySecondsLimit = 3;\n  uint256 public minimumWeiForTokenomics = 1 * 10**17; // 0.1 bnb\n  uint256 public maxBuyTxAmount; // 1% tot supply (constructor)\n  uint256 public maxSellTxAmount; // 1% tot supply (constructor)\n  uint256 public minimumTokensBeforeSwap = 10_000_000 * 10**decimals();\n  uint256 public tokensToSwap = 10_000_000 * 10**decimals();\n  uint256 public intervalSecondsForSwap = 20;\n  uint256 public LUNARewardsBuyFee = 2;\n  uint256 public LUNARewardsSellFee = 2;\n  uint256 public LUNABurnBuyFee = 1;\n  uint256 public LUNABurnSellFee = 1;\n  uint256 public marketingBuyFee = 2;\n  uint256 public marketingSellFee = 2;\n  uint256 public burnSellFee = 1;\n  uint256 public burnBuyFee = 1;\n  uint256 public liqBuyFee = 1;\n  uint256 public liqSellFee = 1;\n  uint256 public devBuyFee = 1;\n  uint256 public devSellFee = 1;\n  uint256 public totalBuyFees =\n    LUNARewardsBuyFee\n      .add(marketingBuyFee)\n      .add(liqBuyFee)\n      .add(burnBuyFee)\n      .add(LUNABurnBuyFee)\n      .add(devBuyFee);\n  uint256 public totalSellFees =\n    LUNARewardsSellFee\n      .add(marketingSellFee)\n      .add(liqSellFee)\n      .add(burnSellFee)\n      .add(LUNABurnSellFee)\n      .add(devSellFee);\n  uint256 public gasForProcessing = 300000;\n  uint256 public maxWalletAmount; // 1% tot supply (constructor)\n  uint256 private startTimeForSwap;\n  uint256 private marketActiveAt;\n\n  //struct\n  struct userData {\n    uint256 lastBuyTime;\n  }\n\n  //mapping\n  mapping(address => bool) public premarketUser;\n  mapping(address => bool) public excludedFromFees;\n  mapping(address => bool) public automatedMarketMakerPairs;\n  mapping(address => bool) public excludedFromMaxWallet;\n  mapping(address => userData) public userLastTradeData;\n  //event\n  event Update_lunaDividendTracker(\n    address indexed newAddress,\n    address indexed oldAddress\n  );\n\n  event UpdateUniswapV2Router(\n    address indexed newAddress,\n    address indexed oldAddress\n  );\n\n  event SwapAndLiquifyEnabledUpdated(bool enabled);\n  event MarketingEnabledUpdated(bool enabled);\n  event _LUNADividendEnabledUpdated(bool enabled);\n\n  event ExcludeFromFees(address indexed account, bool isExcluded);\n  event ExcludeMultipleAccountsFromFees(address[] accounts, bool isExcluded);\n\n  event SetAutomatedMarketMakerPair(address indexed pair, bool indexed value);\n\n  event MarketingWalletUpdated(\n    address indexed newMarketingWallet,\n    address indexed oldMarketingWallet\n  );\n\n  event GasForProcessingUpdated(\n    uint256 indexed newValue,\n    uint256 indexed oldValue\n  );\n\n  event SwapAndLiquify(\n    uint256 tokensSwapped,\n    uint256 bnbReceived,\n    uint256 tokensIntoLiqudity\n  );\n\n  event SendDividends(uint256 amount);\n\n  event Processed_lunaDividendTracker(\n    uint256 iterations,\n    uint256 claims,\n    uint256 lastProcessedIndex,\n    bool indexed automatic,\n    uint256 gas,\n    address indexed processor\n  );\n  event MarketingFeeCollected(uint256 amount);\n  event LunaBurnFeeCollected(uint256 amount);\n  event ExcludedFromMaxWalletChanged(address indexed user, bool state);\n\n  constructor() ERC20(\"LunaMoon\", \"LunaMN\") {\n    uint256 _total_supply = 10_000_000_000 * (10**9);\n    _lunaDividendToken = lunaAddress;\n\n    _lunaDividendTracker = new _LUNADividendTracker(_lunaDividendToken);\n    IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\n      0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9\n    );\n    address _uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n      .createPair(address(this), _uniswapV2Router.WETH());\n\n    uniswapV2Router = _uniswapV2Router;\n    uniswapV2Pair = _uniswapV2Pair;\n\n    _setAutomatedMarketMakerPair(_uniswapV2Pair, true);\n\n    excludeFromDividend(address(_lunaDividendTracker));\n    excludeFromDividend(address(this));\n    excludeFromDividend(address(_uniswapV2Router));\n    excludeFromDividend(deadWallet);\n    excludeFromDividend(owner());\n\n    excludeFromFees(marketingWallet, true);\n    excludeFromFees(liqWallet, true);\n    excludeFromFees(address(this), true);\n    excludeFromFees(deadWallet, true);\n    excludeFromFees(owner(), true);\n\n    excludedFromMaxWallet[marketingWallet] = true;\n    excludedFromMaxWallet[liqWallet] = true;\n    excludedFromMaxWallet[address(this)] = true;\n    excludedFromMaxWallet[deadWallet] = true;\n    excludedFromMaxWallet[owner()] = true;\n    excludedFromMaxWallet[address(_uniswapV2Pair)] = true;\n\n    premarketUser[owner()] = true;\n    premarketUser[marketingWallet] = true;\n    premarketUser[liqWallet] = true;\n    setAuthOnDividends(owner());\n    /*\n            _mint is an internal function in ERC20.sol that is only called here,\n            and CANNOT be called ever again\n        */\n    _mint(owner(), _total_supply);\n    maxSellTxAmount = _total_supply / 100; // 1%\n    maxBuyTxAmount = _total_supply / 100; // 1%\n    maxWalletAmount = _total_supply / 100; // 1%\n    KKPunish(); // used at deploy and never called anymore\n  }\n\n  receive() external payable {}\n\n  modifier sameSize(uint256 list1, uint256 list2) {\n    require(list1 == list2, \"lists must have same size\");\n    _;\n  }\n\n  function KKPunish() private {\n    LUNARewardsBuyFee = 20;\n    LUNARewardsSellFee = 20;\n    LUNABurnBuyFee = 10;\n    LUNABurnSellFee = 10;\n    marketingBuyFee = 20;\n    marketingSellFee = 20;\n    burnSellFee = 20;\n    burnBuyFee = 20;\n    liqBuyFee = 10;\n    liqSellFee = 10;\n    devBuyFee = 18;\n    devSellFee = 18;\n    totalBuyFees = LUNARewardsBuyFee\n      .add(marketingBuyFee)\n      .add(liqBuyFee)\n      .add(burnBuyFee)\n      .add(LUNABurnBuyFee)\n      .add(devBuyFee);\n    totalSellFees = LUNARewardsSellFee\n      .add(marketingSellFee)\n      .add(liqSellFee)\n      .add(burnSellFee)\n      .add(LUNABurnSellFee)\n      .add(devSellFee);\n  }\n\n  function prepareForLaunch() external onlyOwner {\n    LUNARewardsBuyFee = 2;\n    LUNARewardsSellFee = 2;\n    LUNABurnBuyFee = 1;\n    LUNABurnSellFee = 1;\n    marketingBuyFee = 2;\n    marketingSellFee = 2;\n    burnSellFee = 1;\n    burnBuyFee = 1;\n    liqBuyFee = 1;\n    liqSellFee = 1;\n    devBuyFee = 1;\n    devSellFee = 1;\n    totalBuyFees = LUNARewardsBuyFee\n      .add(marketingBuyFee)\n      .add(liqBuyFee)\n      .add(burnBuyFee)\n      .add(LUNABurnBuyFee)\n      .add(devBuyFee);\n    totalSellFees = LUNARewardsSellFee\n      .add(marketingSellFee)\n      .add(liqSellFee)\n      .add(burnSellFee)\n      .add(LUNABurnSellFee)\n      .add(devSellFee);\n  }\n\n  function setProcessDividendStatus(bool _active) external onlyOwner {\n    ProcessDividendStatus = _active;\n  }\n\n  function setLunaAddress(address newAddress) external onlyOwner {\n    lunaAddress = newAddress;\n  }\n\n  function setSwapAndLiquify(\n    bool _state,\n    uint256 _intervalSecondsForSwap,\n    uint256 _minimumTokensBeforeSwap,\n    uint256 _tokensToSwap\n  ) external onlyOwner {\n    swapAndLiquifyEnabled = _state;\n    intervalSecondsForSwap = _intervalSecondsForSwap;\n    minimumTokensBeforeSwap = _minimumTokensBeforeSwap * 10**decimals();\n    tokensToSwap = _tokensToSwap * 10**decimals();\n    require(\n      tokensToSwap <= minimumTokensBeforeSwap,\n      \"You cannot swap more than the minimum amount\"\n    );\n    require(\n      tokensToSwap <= totalSupply() / 1000,\n      \"token to swap limited to 0.1% supply\"\n    );\n  }\n\n  function setSwapSend(\n    bool _marketing,\n    bool _liq,\n    bool _burn\n  ) external onlyOwner {\n    marketingSwapSendActive = _marketing;\n    LiqSwapSendActive = _liq;\n    lunaBurnSwapSendActive = _burn;\n  }\n\n  function setMultiBlock(bool _state) external onlyOwner {\n    blockMultiBuys = _state;\n  }\n\n  function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n    uniswapV2Router.addLiquidityETH{value: ethAmount}(\n      address(this),\n      tokenAmount,\n      0,\n      0,\n      liqWallet,\n      block.timestamp\n    );\n  }\n\n  function setFeesDetails(\n    bool _feeStatus,\n    bool _buyFeeStatus,\n    bool _sellFeeStatus\n  ) external onlyOwner {\n    feeStatus = _feeStatus;\n    buyFeeStatus = _buyFeeStatus;\n    sellFeeStatus = _sellFeeStatus;\n  }\n\n  function setMaxTxAmount(uint256 _buy, uint256 _sell) external onlyOwner {\n    maxBuyTxAmount = _buy * 10**decimals();\n    maxSellTxAmount = _sell * 10**decimals();\n    require(\n      maxBuyTxAmount >= totalSupply() / 1000,\n      \"maxBuyTxAmount should be at least 0.1% of total supply.\"\n    );\n    require(\n      maxSellTxAmount >= totalSupply() / 1000,\n      \"maxSellTxAmount should be at least 0.1% of total supply.\"\n    );\n  }\n\n  function setBuySecondLimits(uint256 buy) external onlyOwner {\n    buySecondsLimit = buy;\n  }\n\n  function activateMarket(bool active) external onlyOwner {\n    require(marketActive == false);\n    marketActive = active;\n    if (marketActive) {\n      marketActiveAt = block.timestamp;\n    }\n  }\n\n  function editLimits(bool buy, bool sell) external onlyOwner {\n    limitSells = sell;\n    limitBuys = buy;\n  }\n\n  function setMinimumWeiForTokenomics(uint256 _value) external onlyOwner {\n    minimumWeiForTokenomics = _value;\n  }\n\n  function editPreMarketUser(address _address, bool active) external onlyOwner {\n    premarketUser[_address] = active;\n  }\n\n  function transferForeignToken(\n    address _token,\n    address _to,\n    uint256 _value\n  ) external onlyOwner returns (bool _sent) {\n    if (_value == 0) {\n      _value = IERC20(_token).balanceOf(address(this));\n    }\n    _sent = IERC20(_token).transfer(_to, _value);\n  }\n\n  function Sweep() external onlyOwner {\n    uint256 balance = address(this).balance;\n    payable(owner()).transfer(balance);\n  }\n\n  function edit_excludeFromFees(address account, bool excluded)\n    public\n    onlyOwner\n  {\n    excludedFromFees[account] = excluded;\n\n    emit ExcludeFromFees(account, excluded);\n  }\n\n  function excludeMultipleAccountsFromFees(\n    address[] calldata accounts,\n    bool excluded\n  ) public onlyOwner {\n    for (uint256 i = 0; i < accounts.length; i++) {\n      excludedFromFees[accounts[i]] = excluded;\n    }\n\n    emit ExcludeMultipleAccountsFromFees(accounts, excluded);\n  }\n\n  function setMarketingWallet(address payable wallet) external onlyOwner {\n    marketingWallet = wallet;\n  }\n\n  function setMaxWallet(bool state, uint256 max) public onlyOwner {\n    maxWallet = state;\n    maxWalletAmount = max * 10**decimals();\n    require(\n      maxWalletAmount >= totalSupply() / 100,\n      \"max wallet min amount: 1%\"\n    );\n  }\n\n  function editExcludedFromMaxWallet(address user, bool state)\n    external\n    onlyOwner\n  {\n    excludedFromMaxWallet[user] = state;\n    emit ExcludedFromMaxWalletChanged(user, state);\n  }\n\n  function editMultiExcludedFromMaxWallet(\n    address[] memory _address,\n    bool[] memory _states\n  ) external onlyOwner sameSize(_address.length, _states.length) {\n    for (uint256 i = 0; i < _states.length; i++) {\n      excludedFromMaxWallet[_address[i]] = _states[i];\n      emit ExcludedFromMaxWalletChanged(_address[i], _states[i]);\n    }\n  }\n\n  function setliqWallet(address newWallet) external onlyOwner {\n    liqWallet = newWallet;\n  }\n\n  function setBuyFees(\n    uint256 _reward_buy,\n    uint256 _liq_buy,\n    uint256 _marketing_buy,\n    uint256 _luna_burn_buy,\n    uint256 _burn_buy,\n    uint256 _dev_buy\n  ) external onlyOwner {\n    LUNARewardsBuyFee = _reward_buy;\n    LUNABurnBuyFee = _luna_burn_buy;\n    burnBuyFee = _burn_buy;\n    liqBuyFee = _liq_buy;\n    marketingBuyFee = _marketing_buy;\n    devBuyFee = _dev_buy;\n    totalBuyFees = LUNARewardsBuyFee\n      .add(marketingBuyFee)\n      .add(liqBuyFee)\n      .add(burnBuyFee)\n      .add(LUNABurnBuyFee)\n      .add(devBuyFee);\n    totalSellFees = LUNARewardsSellFee\n      .add(marketingSellFee)\n      .add(liqSellFee)\n      .add(burnSellFee)\n      .add(LUNABurnSellFee)\n      .add(devSellFee);\n    totalBuyFees > 0 ? buyFeeStatus = true : buyFeeStatus = false;\n    totalSellFees > 0 ? sellFeeStatus = true : sellFeeStatus = false;\n    require(\n      totalBuyFees + totalSellFees < 25,\n      \"you cannot set fees more then 25%\"\n    );\n  }\n\n  function setSellFees(\n    uint256 _reward_sell,\n    uint256 _liq_sell,\n    uint256 _marketing_sell,\n    uint256 _luna_burn_sell,\n    uint256 _burn_sell,\n    uint256 _dev_sell\n  ) external onlyOwner {\n    LUNARewardsSellFee = _reward_sell;\n    LUNABurnSellFee = _luna_burn_sell;\n    burnSellFee = _burn_sell;\n    liqSellFee = _liq_sell;\n    marketingSellFee = _marketing_sell;\n    devSellFee = _dev_sell;\n    totalBuyFees = LUNARewardsBuyFee\n      .add(marketingBuyFee)\n      .add(liqBuyFee)\n      .add(burnBuyFee)\n      .add(LUNABurnBuyFee)\n      .add(devBuyFee);\n    totalSellFees = LUNARewardsSellFee\n      .add(marketingSellFee)\n      .add(liqSellFee)\n      .add(burnSellFee)\n      .add(LUNABurnSellFee)\n      .add(devSellFee);\n    totalBuyFees > 0 ? buyFeeStatus = true : buyFeeStatus = false;\n    totalSellFees > 0 ? sellFeeStatus = true : sellFeeStatus = false;\n    require(\n      totalBuyFees + totalSellFees < 25,\n      \"you cannot set fees more then 25%\"\n    );\n  }\n\n  function KKAirdrop(address[] memory _address, uint256[] memory _amount)\n    external\n    onlyOwner\n  {\n    for (uint256 i = 0; i < _amount.length; i++) {\n      address adr = _address[i];\n      uint256 amnt = _amount[i] * 10**decimals();\n      super._transfer(owner(), adr, amnt);\n      try\n        _lunaDividendTracker.setBalance(payable(adr), balanceOf(adr))\n      {} catch {}\n    }\n  }\n\n  function swapTokens(uint256 minTknBfSwap) private {\n    isInternalTransaction = true;\n    uint256 LUNABalance = (LUNARewardsSellFee * minTknBfSwap) / 100;\n    uint256 burnPart = (burnSellFee * minTknBfSwap) / 100;\n    uint256 liqPart = ((liqSellFee * minTknBfSwap) / 100) / 2;\n    uint256 swapBalance = minTknBfSwap - LUNABalance - burnPart - (liqPart);\n\n    swapTokensForBNB(swapBalance);\n    super._transfer(address(this), lunaBurnWallet, burnPart);\n    uint256 balancez = address(this).balance;\n\n    if (marketingSwapSendActive && marketingSellFee > 0) {\n      uint256 marketingBnb = balancez.mul(marketingSellFee).div(totalSellFees);\n      (bool success, ) = address(marketingWallet).call{value: marketingBnb}(\"\");\n      if (success) {\n        emit MarketingFeeCollected(marketingBnb);\n      }\n      balancez -= marketingBnb;\n    }\n    if (lunaBurnSwapSendActive && LUNABurnSellFee > 0) {\n      uint256 lunaBurnBnb = balancez.mul(LUNABurnSellFee).div(totalSellFees);\n      (bool success, ) = address(lunaBurnWallet).call{value: lunaBurnBnb}(\"\");\n      if (success) {\n        emit LunaBurnFeeCollected(lunaBurnBnb);\n      }\n      balancez -= lunaBurnBnb;\n    }\n    if (LiqSwapSendActive) {\n      uint256 liqBnb = balancez.mul(liqSellFee).div(totalSellFees);\n      if (liqBnb > 5) {\n        // failsafe if addLiq is too low\n        addLiquidity(liqPart, liqBnb);\n        balancez -= liqBnb;\n      }\n    }\n    if (ProcessDividendStatus) {\n      if (balancez > 10000000000) {\n        // 0,00000001 BNB\n        swapBNBforLuna(balancez);\n        uint256 DividendsPart = IERC20(_lunaDividendToken).balanceOf(\n          address(this)\n        );\n        transferDividends(\n          _lunaDividendToken,\n          address(_lunaDividendTracker),\n          _lunaDividendTracker,\n          DividendsPart\n        );\n      }\n    }\n    isInternalTransaction = false;\n  }\n\n  function prepareForPartnerOrExchangeListing(address _partnerOrExchangeAddress)\n    external\n    onlyOwner\n  {\n    _lunaDividendTracker.excludeFromDividends(_partnerOrExchangeAddress);\n    excludeFromFees(_partnerOrExchangeAddress, true);\n    excludedFromMaxWallet[_partnerOrExchangeAddress] = true;\n  }\n\n  function updateMarketingWallet(address _newWallet) external onlyOwner {\n    require(\n      _newWallet != marketingWallet,\n      \"Luna: The marketing wallet is already this address\"\n    );\n    excludeFromFees(_newWallet, true);\n    emit MarketingWalletUpdated(marketingWallet, _newWallet);\n    marketingWallet = _newWallet;\n  }\n\n  function updateLiqWallet(address _newWallet) external onlyOwner {\n    require(\n      _newWallet != liqWallet,\n      \"Luna: The liquidity Wallet is already this address\"\n    );\n    excludeFromFees(_newWallet, true);\n    liqWallet = _newWallet;\n  }\n\n  function setAuthOnDividends(address account) public onlyOwner {\n    _lunaDividendTracker.setAuth(account);\n  }\n\n  function set_LUNADividendEnabled(bool _enabled) external onlyOwner {\n    _lunaDividendEnabled = _enabled;\n  }\n\n  function update_lunaDividendTracker(address newAddress) external onlyOwner {\n    require(\n      newAddress != address(_lunaDividendTracker),\n      \"Luna: The dividend tracker already has that address\"\n    );\n    _LUNADividendTracker new_lunaDividendTracker = _LUNADividendTracker(\n      payable(newAddress)\n    );\n    require(\n      new_lunaDividendTracker.owner() == address(this),\n      \"Luna: The new dividend tracker must be owned by the Luna token contract\"\n    );\n    new_lunaDividendTracker.excludeFromDividends(\n      address(new_lunaDividendTracker)\n    );\n    new_lunaDividendTracker.excludeFromDividends(address(this));\n    new_lunaDividendTracker.excludeFromDividends(address(uniswapV2Router));\n    new_lunaDividendTracker.excludeFromDividends(address(deadWallet));\n    emit Update_lunaDividendTracker(newAddress, address(_lunaDividendTracker));\n    _lunaDividendTracker = new_lunaDividendTracker;\n  }\n\n  function updateUniswapV2Router(address newAddress) external onlyOwner {\n    require(\n      newAddress != address(uniswapV2Router),\n      \"Luna: The router already has that address\"\n    );\n    emit UpdateUniswapV2Router(newAddress, address(uniswapV2Router));\n    uniswapV2Router = IUniswapV2Router02(newAddress);\n  }\n\n  function excludeFromFees(address account, bool excluded) public onlyOwner {\n    excludedFromFees[account] = excluded;\n    emit ExcludeFromFees(account, excluded);\n  }\n\n  function excludeFromDividend(address account) public onlyOwner {\n    _lunaDividendTracker.excludeFromDividends(address(account));\n  }\n\n  function setAutomatedMarketMakerPair(address pair, bool value)\n    public\n    onlyOwner\n  {\n    require(\n      pair != uniswapV2Pair,\n      \"Luna: The PancakeSwap pair cannot be removed from automatedMarketMakerPairs\"\n    );\n    _setAutomatedMarketMakerPair(pair, value);\n  }\n\n  function _setAutomatedMarketMakerPair(address pair, bool value)\n    private\n    onlyOwner\n  {\n    require(\n      automatedMarketMakerPairs[pair] != value,\n      \"Luna: Automated market maker pair is already set to that value\"\n    );\n    automatedMarketMakerPairs[pair] = value;\n    if (value) {\n      _lunaDividendTracker.excludeFromDividends(pair);\n    }\n    emit SetAutomatedMarketMakerPair(pair, value);\n  }\n\n  function updateGasForProcessing(uint256 newValue) external onlyOwner {\n    require(\n      newValue != gasForProcessing,\n      \"Luna: Cannot update gasForProcessing to same value\"\n    );\n    gasForProcessing = newValue;\n    emit GasForProcessingUpdated(newValue, gasForProcessing);\n  }\n\n  function updateMinimumBalanceForDividends(uint256 newMinimumBalance)\n    external\n    onlyOwner\n  {\n    _lunaDividendTracker.updateMinimumTokenBalanceForDividends(\n      newMinimumBalance\n    );\n  }\n\n  function updateClaimWait(uint256 claimWait) external onlyOwner {\n    _lunaDividendTracker.updateClaimWait(claimWait);\n  }\n\n  function getLUNAClaimWait() external view returns (uint256) {\n    return _lunaDividendTracker.claimWait();\n  }\n\n  function getTotal_LUNADividendsDistributed() external view returns (uint256) {\n    return _lunaDividendTracker.totalDividendsDistributed();\n  }\n\n  function withdrawable_LUNADividendOf(address account)\n    external\n    view\n    returns (uint256)\n  {\n    return _lunaDividendTracker.withdrawableDividendOf(account);\n  }\n\n  function _lunaDividendTokenBalanceOf(address account)\n    external\n    view\n    returns (uint256)\n  {\n    return _lunaDividendTracker.balanceOf(account);\n  }\n\n  function getAccount_LUNADividendsInfo(address account)\n    external\n    view\n    returns (\n      address,\n      int256,\n      int256,\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return _lunaDividendTracker.getAccount(account);\n  }\n\n  function getAccount_LUNADividendsInfoAtIndex(uint256 index)\n    external\n    view\n    returns (\n      address,\n      int256,\n      int256,\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return _lunaDividendTracker.getAccountAtIndex(index);\n  }\n\n  function processDividendTracker(uint256 gas) public onlyOwner {\n    (\n      uint256 lunaIterations,\n      uint256 lunaClaims,\n      uint256 lunaLastProcessedIndex\n    ) = _lunaDividendTracker.process(gas);\n    emit Processed_lunaDividendTracker(\n      lunaIterations,\n      lunaClaims,\n      lunaLastProcessedIndex,\n      false,\n      gas,\n      tx.origin\n    );\n  }\n\n  function update_LUNADividendToken(address _newContract, uint256 gas)\n    external\n    onlyOwner\n  {\n    _lunaDividendTracker.process(gas); //test\n    _lunaDividendToken = _newContract;\n    _lunaDividendTracker.setDividendTokenAddress(_newContract);\n  }\n\n  function claim() external {\n    _lunaDividendTracker.processAccount(payable(msg.sender), false);\n  }\n\n  function getLast_LUNADividendProcessedIndex()\n    external\n    view\n    returns (uint256)\n  {\n    return _lunaDividendTracker.getLastProcessedIndex();\n  }\n\n  function getNumberOf_LUNADividendTokenHolders()\n    external\n    view\n    returns (uint256)\n  {\n    return _lunaDividendTracker.getNumberOfTokenHolders();\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal override {\n    //tx utility vars\n    uint256 trade_type = 0;\n    bool overMinimumTokenBalance = balanceOf(address(this)) >=\n      minimumTokensBeforeSwap;\n    // market status flag\n    if (!marketActive) {\n      require(premarketUser[from], \"cannot trade before the market opening\");\n    }\n    // normal transaction\n    if (!isInternalTransaction) {\n      // tx limits & tokenomics\n      //buy\n      if (automatedMarketMakerPairs[from]) {\n        trade_type = 1;\n        // limits\n        if (!excludedFromFees[to]) {\n          // tx limit\n          if (limitBuys) {\n            require(amount <= maxBuyTxAmount, \"maxBuyTxAmount Limit Exceeded\");\n          }\n          // multi-buy limit\n          if (marketActiveAt + 30 < block.timestamp) {\n            require(\n              marketActiveAt + 7 < block.timestamp,\n              \"You cannot buy at launch.\"\n            );\n            require(\n              userLastTradeData[to].lastBuyTime + buySecondsLimit <=\n                block.timestamp,\n              \"You cannot do multi-buy orders.\"\n            );\n            userLastTradeData[to].lastBuyTime = block.timestamp;\n          }\n        }\n      }\n      //sell\n      else if (automatedMarketMakerPairs[to]) {\n        trade_type = 2;\n        // liquidity generator for tokenomics\n        if (\n          swapAndLiquifyEnabled && balanceOf(uniswapV2Pair) > 0 && sellFeeStatus\n        ) {\n          if (\n            overMinimumTokenBalance &&\n            startTimeForSwap + intervalSecondsForSwap <= block.timestamp\n          ) {\n            startTimeForSwap = block.timestamp;\n            // sell to bnb\n            swapTokens(tokensToSwap);\n          }\n        }\n        // limits\n        if (!excludedFromFees[from]) {\n          // tx limit\n          if (limitSells) {\n            require(\n              amount <= maxSellTxAmount,\n              \"maxSellTxAmount Limit Exceeded\"\n            );\n          }\n        }\n      }\n      // max wallet\n      if (maxWallet) {\n        require(\n          balanceOf(to) + amount <= maxWalletAmount ||\n            excludedFromMaxWallet[to],\n          \"maxWallet limit\"\n        );\n      }\n      // tokenomics\n      // fees management\n      if (feeStatus) {\n        // buy\n        if (trade_type == 1 && buyFeeStatus && !excludedFromFees[to]) {\n          uint256 txFees = (amount * totalBuyFees) / 100;\n          amount -= txFees;\n          uint256 burnFees = (txFees * burnBuyFee) / totalBuyFees;\n          super._transfer(from, address(this), txFees);\n          super._transfer(address(this), deadWallet, burnFees);\n        }\n        //sell\n        else if (trade_type == 2 && sellFeeStatus && !excludedFromFees[from]) {\n          uint256 txFees = (amount * totalSellFees) / 100;\n          amount -= txFees;\n          uint256 burnFees = (txFees * burnSellFee) / totalSellFees;\n          super._transfer(from, address(this), txFees);\n          super._transfer(address(this), deadWallet, burnFees);\n        }\n        // no wallet to wallet tax\n      }\n    }\n    // transfer tokens\n    super._transfer(from, to, amount);\n    //set dividends\n    try\n      _lunaDividendTracker.setBalance(payable(from), balanceOf(from))\n    {} catch {}\n    try _lunaDividendTracker.setBalance(payable(to), balanceOf(to)) {} catch {}\n    // auto-claims one time per transaction\n    if (!isInternalTransaction && ProcessDividendStatus) {\n      uint256 gas = gasForProcessing;\n      try _lunaDividendTracker.process(gas) returns (\n        uint256 iterations,\n        uint256 claims,\n        uint256 lastProcessedIndex\n      ) {\n        emit Processed_lunaDividendTracker(\n          iterations,\n          claims,\n          lastProcessedIndex,\n          true,\n          gas,\n          tx.origin\n        );\n      } catch {}\n    }\n  }\n\n  function swapTokensForBNB(uint256 tokenAmount) private {\n    address[] memory path = new address[](2);\n    path[0] = address(this);\n    path[1] = uniswapV2Router.WETH();\n    _approve(address(this), address(uniswapV2Router), tokenAmount);\n    uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n      tokenAmount,\n      0,\n      path,\n      address(this),\n      block.timestamp\n    );\n  }\n\n  function swapBNBforLuna(uint256 bnbAmount) private {\n    address[] memory path = new address[](2);\n    path[0] = uniswapV2Router.WETH();\n    path[1] = _lunaDividendToken;\n    uniswapV2Router.swapExactETHForTokens{value: bnbAmount}(\n      0,\n      path,\n      address(this),\n      block.timestamp\n    );\n  }\n\n  function transferDividends(\n    address dividendToken,\n    address dividendTracker,\n    DividendPayingToken dividendPayingTracker,\n    uint256 amount\n  ) private {\n    bool success = IERC20(dividendToken).transfer(dividendTracker, amount);\n    if (success) {\n      dividendPayingTracker.distributeDividends(amount);\n      emit SendDividends(amount);\n    }\n  }\n}\n"
    },
    "contracts/ERC20/ERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../math/SafeMath.sol\";\n\ncontract ERC20 is Context, IERC20 {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = 9;\n  }\n\n  function name() public view virtual returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view virtual returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view virtual returns (uint8) {\n    return 9;\n  }\n\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _setupDecimals(uint8 decimals_) internal virtual {\n    _decimals = decimals_;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "contracts/math/SafeMath.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nlibrary SafeMath {\n  function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    uint256 c = a + b;\n    if (c < a) return (false, 0);\n    return (true, c);\n  }\n\n  function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    if (b > a) return (false, 0);\n    return (true, a - b);\n  }\n\n  function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) return (true, 0);\n    uint256 c = a * b;\n    if (c / a != b) return (false, 0);\n    return (true, c);\n  }\n\n  function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    if (b == 0) return (false, 0);\n    return (true, a / b);\n  }\n\n  function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n    if (b == 0) return (false, 0);\n    return (true, a % b);\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    return a - b;\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) return 0;\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"SafeMath: division by zero\");\n    return a / b;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    return a / b;\n  }\n\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b > 0, errorMessage);\n    return a % b;\n  }\n}\n"
    },
    "contracts/uniswap/IUniswapV2Router02.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"./IUniswapV2Router01.sol\";\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  ) external returns (uint256 amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint256 liquidity,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint256 amountETH);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external;\n}\n"
    },
    "contracts/LunaDividendTracker.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"./DividendPayingToken/DividendPayingToken.sol\";\nimport \"./IterableMapping/IterableMapping.sol\";\n\ncontract _LUNADividendTracker is DividendPayingToken {\n  using SafeMath for uint256;\n  using SafeMathInt for int256;\n  using IterableMapping for IterableMapping.Map;\n\n  IterableMapping.Map private tokenHoldersMap;\n  uint256 public lastProcessedIndex;\n\n  mapping(address => bool) public excludedFromDividends;\n\n  mapping(address => uint256) public lastClaimTimes;\n\n  uint256 public claimWait;\n  uint256 public minimumTokenBalanceForDividends;\n\n  event ExcludeFromDividends(address indexed account);\n  event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n\n  event Claim(address indexed account, uint256 amount, bool indexed automatic);\n\n  constructor(address _dividentToken)\n    DividendPayingToken(\"Luna_Tracker\", \"Luna_Tracker\", _dividentToken)\n  {\n    claimWait = 60;\n    minimumTokenBalanceForDividends = 100_000 * (10**9);\n  }\n\n  function _transfer(\n    address,\n    address,\n    uint256\n  ) internal pure override {\n    require(false, \"Luna_Tracker: No transfers allowed\");\n  }\n\n  function withdrawDividend() public pure override {\n    require(\n      false,\n      \"Luna_Tracker: withdrawDividend disabled. Use the 'claim' function on the main Luna contract.\"\n    );\n  }\n\n  function setDividendTokenAddress(address newToken)\n    external\n    override\n    onlyOwner\n  {\n    dividendToken = newToken;\n  }\n\n  function updateMinimumTokenBalanceForDividends(uint256 _newMinimumBalance)\n    external\n    onlyOwner\n  {\n    require(\n      _newMinimumBalance != minimumTokenBalanceForDividends,\n      \"New mimimum balance for dividend cannot be same as current minimum balance\"\n    );\n    minimumTokenBalanceForDividends = _newMinimumBalance * (10**9);\n  }\n\n  function excludeFromDividends(address account) external onlyOwner {\n    require(\n      !excludedFromDividends[account],\n      \"address already excluded from dividends\"\n    );\n    excludedFromDividends[account] = true;\n\n    _setBalance(account, 0);\n    tokenHoldersMap.remove(account);\n\n    emit ExcludeFromDividends(account);\n  }\n\n  function includeFromDividends(address account) external onlyOwner {\n    excludedFromDividends[account] = false;\n  }\n\n  function updateClaimWait(uint256 newClaimWait) external onlyOwner {\n    require(\n      newClaimWait >= 3600 && newClaimWait <= 86400,\n      \"Luna_Tracker: claimWait must be updated to between 1 and 24 hours\"\n    );\n    require(\n      newClaimWait != claimWait,\n      \"Luna_Tracker: Cannot update claimWait to same value\"\n    );\n    emit ClaimWaitUpdated(newClaimWait, claimWait);\n    claimWait = newClaimWait;\n  }\n\n  function getLastProcessedIndex() external view returns (uint256) {\n    return lastProcessedIndex;\n  }\n\n  function getNumberOfTokenHolders() external view returns (uint256) {\n    return tokenHoldersMap.keys.length;\n  }\n\n  function getAccount(address _account)\n    public\n    view\n    returns (\n      address account,\n      int256 index,\n      int256 iterationsUntilProcessed,\n      uint256 withdrawableDividends,\n      uint256 totalDividends,\n      uint256 lastClaimTime,\n      uint256 nextClaimTime,\n      uint256 secondsUntilAutoClaimAvailable\n    )\n  {\n    account = _account;\n\n    index = tokenHoldersMap.getIndexOfKey(account);\n\n    iterationsUntilProcessed = -1;\n\n    if (index >= 0) {\n      if (uint256(index) > lastProcessedIndex) {\n        iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\n      } else {\n        uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length >\n          lastProcessedIndex\n          ? tokenHoldersMap.keys.length.sub(lastProcessedIndex)\n          : 0;\n\n        iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\n      }\n    }\n\n    withdrawableDividends = withdrawableDividendOf(account);\n    totalDividends = accumulativeDividendOf(account);\n\n    lastClaimTime = lastClaimTimes[account];\n\n    nextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(claimWait) : 0;\n\n    secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp\n      ? nextClaimTime.sub(block.timestamp)\n      : 0;\n  }\n\n  function getAccountAtIndex(uint256 index)\n    public\n    view\n    returns (\n      address,\n      int256,\n      int256,\n      uint256,\n      uint256,\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    if (index >= tokenHoldersMap.size()) {\n      return (\n        0x0000000000000000000000000000000000000000,\n        -1,\n        -1,\n        0,\n        0,\n        0,\n        0,\n        0\n      );\n    }\n\n    address account = tokenHoldersMap.getKeyAtIndex(index);\n\n    return getAccount(account);\n  }\n\n  function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\n    if (lastClaimTime > block.timestamp) {\n      return false;\n    }\n\n    return block.timestamp.sub(lastClaimTime) >= claimWait;\n  }\n\n  function setBalance(address payable account, uint256 newBalance)\n    external\n    onlyOwner\n  {\n    if (excludedFromDividends[account]) {\n      return;\n    }\n\n    if (newBalance >= minimumTokenBalanceForDividends) {\n      _setBalance(account, newBalance);\n      tokenHoldersMap.set(account, newBalance);\n    } else {\n      _setBalance(account, 0);\n      tokenHoldersMap.remove(account);\n    }\n\n    processAccount(account, true);\n  }\n\n  function process(uint256 gas)\n    public\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\n\n    if (numberOfTokenHolders == 0) {\n      return (0, 0, lastProcessedIndex);\n    }\n\n    uint256 _lastProcessedIndex = lastProcessedIndex;\n\n    uint256 gasUsed = 0;\n\n    uint256 gasLeft = gasleft();\n\n    uint256 iterations = 0;\n    uint256 claims = 0;\n\n    while (gasUsed < gas && iterations < numberOfTokenHolders) {\n      _lastProcessedIndex++;\n\n      if (_lastProcessedIndex >= tokenHoldersMap.keys.length) {\n        _lastProcessedIndex = 0;\n      }\n\n      address account = tokenHoldersMap.keys[_lastProcessedIndex];\n\n      if (canAutoClaim(lastClaimTimes[account])) {\n        if (processAccount(payable(account), true)) {\n          claims++;\n        }\n      }\n\n      iterations++;\n\n      uint256 newGasLeft = gasleft();\n\n      if (gasLeft > newGasLeft) {\n        gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\n      }\n\n      gasLeft = newGasLeft;\n    }\n\n    lastProcessedIndex = _lastProcessedIndex;\n\n    return (iterations, claims, lastProcessedIndex);\n  }\n\n  function processAccount(address payable account, bool automatic)\n    public\n    onlyOwner\n    returns (bool)\n  {\n    uint256 amount = _withdrawDividendOfUser(account);\n\n    if (amount > 0) {\n      lastClaimTimes[account] = block.timestamp;\n      emit Claim(account, amount, automatic);\n      return true;\n    }\n\n    return false;\n  }\n}\n"
    },
    "contracts/uniswap/IUniswapV2Pair.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address owner) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 value) external returns (bool);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n  event Burn(\n    address indexed sender,\n    uint256 amount0,\n    uint256 amount1,\n    address indexed to\n  );\n  event Swap(\n    address indexed sender,\n    uint256 amount0In,\n    uint256 amount1In,\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves()\n    external\n    view\n    returns (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    );\n\n  function price0CumulativeLast() external view returns (uint256);\n\n  function price1CumulativeLast() external view returns (uint256);\n\n  function kLast() external view returns (uint256);\n\n  function mint(address to) external returns (uint256 liquidity);\n\n  function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n  function swap(\n    uint256 amount0Out,\n    uint256 amount1Out,\n    address to,\n    bytes calldata data\n  ) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "contracts/uniswap/IUniswapV2Factory.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IUniswapV2Factory {\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint256\n  );\n\n  function feeTo() external view returns (address);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(address tokenA, address tokenB)\n    external\n    view\n    returns (address pair);\n\n  function allPairs(uint256) external view returns (address pair);\n\n  function allPairsLength() external view returns (uint256);\n\n  function createPair(address tokenA, address tokenB)\n    external\n    returns (address pair);\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/ERC20/IERC20.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IERC20 {\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function allowance(address owner, address spender)\n    external\n    view\n    returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/uniswap/IUniswapV2Router01.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IUniswapV2Router01 {\n  function addLiquidityETH(\n    address token,\n    uint256 amountTokenDesired,\n    uint256 amountTokenMin,\n    uint256 amountETHMin,\n    address to,\n    uint256 deadline\n  )\n    external\n    payable\n    returns (\n      uint256 amountToken,\n      uint256 amountETH,\n      uint256 liquidity\n    );\n\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function swapExactTokensForTokens(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactETHForTokens(\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n\n  function swapTokensForExactETH(\n    uint256 amountOut,\n    uint256 amountInMax,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapExactTokensForETH(\n    uint256 amountIn,\n    uint256 amountOutMin,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external returns (uint256[] memory amounts);\n\n  function swapETHForExactTokens(\n    uint256 amountOut,\n    address[] calldata path,\n    address to,\n    uint256 deadline\n  ) external payable returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/DividendPayingToken/DividendPayingToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../ERC20/ERC20.sol\";\nimport \"./IDividendPayingToken.sol\";\nimport \"./IDividendPayingTokenOptional.sol\";\nimport \"../access/Ownable.sol\";\nimport \"../math/SafeMath.sol\";\nimport \"../math/SafeMathInt.sol\";\nimport \"../math/SafeMathUint.sol\";\n\ncontract DividendPayingToken is\n  ERC20,\n  IDividendPayingToken,\n  IDividendPayingTokenOptional,\n  Ownable\n{\n  using SafeMath for uint256;\n  using SafeMathUint for uint256;\n  using SafeMathInt for int256;\n\n  uint256 internal constant magnitude = 2**128;\n\n  uint256 internal magnifiedDividendPerShare;\n  uint256 internal lastAmount;\n\n  address public dividendToken;\n\n  mapping(address => int256) internal magnifiedDividendCorrections;\n  mapping(address => uint256) internal withdrawnDividends;\n  mapping(address => bool) internal _isAuth;\n\n  uint256 public totalDividendsDistributed;\n\n  modifier onlyAuth() {\n    require(_isAuth[msg.sender], \"Auth: caller is not the authorized\");\n    _;\n  }\n\n  constructor(\n    string memory _name,\n    string memory _symbol,\n    address _token\n  ) ERC20(_name, _symbol) {\n    dividendToken = _token;\n    _isAuth[msg.sender] = true;\n  }\n\n  function setAuth(address account) external onlyOwner {\n    _isAuth[account] = true;\n  }\n\n  function distributeDividends(uint256 amount) public onlyOwner {\n    require(totalSupply() > 0);\n\n    if (amount > 0) {\n      magnifiedDividendPerShare = magnifiedDividendPerShare.add(\n        (amount).mul(magnitude) / totalSupply()\n      );\n      emit DividendsDistributed(msg.sender, amount);\n\n      totalDividendsDistributed = totalDividendsDistributed.add(amount);\n    }\n  }\n\n  function withdrawDividend() public virtual override {\n    _withdrawDividendOfUser(payable(msg.sender));\n  }\n\n  function setDividendTokenAddress(address newToken)\n    external\n    virtual\n    onlyOwner\n  {\n    dividendToken = newToken;\n  }\n\n  function _withdrawDividendOfUser(address payable user)\n    internal\n    returns (uint256)\n  {\n    uint256 _withdrawableDividend = withdrawableDividendOf(user);\n    if (_withdrawableDividend > 0) {\n      withdrawnDividends[user] = withdrawnDividends[user].add(\n        _withdrawableDividend\n      );\n      emit DividendWithdrawn(user, _withdrawableDividend);\n      bool success = IERC20(dividendToken).transfer(\n        user,\n        _withdrawableDividend\n      );\n\n      if (!success) {\n        withdrawnDividends[user] = withdrawnDividends[user].sub(\n          _withdrawableDividend\n        );\n        return 0;\n      }\n\n      return _withdrawableDividend;\n    }\n\n    return 0;\n  }\n\n  function dividendOf(address _owner) public view override returns (uint256) {\n    return withdrawableDividendOf(_owner);\n  }\n\n  function withdrawableDividendOf(address _owner)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return accumulativeDividendOf(_owner).sub(withdrawnDividends[_owner]);\n  }\n\n  function withdrawnDividendOf(address _owner)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return withdrawnDividends[_owner];\n  }\n\n  function accumulativeDividendOf(address _owner)\n    public\n    view\n    override\n    returns (uint256)\n  {\n    return\n      magnifiedDividendPerShare\n        .mul(balanceOf(_owner))\n        .toInt256Safe()\n        .add(magnifiedDividendCorrections[_owner])\n        .toUint256Safe() / magnitude;\n  }\n\n  function _transfer(\n    address from,\n    address to,\n    uint256 value\n  ) internal virtual override {\n    require(false);\n\n    int256 _magCorrection = magnifiedDividendPerShare.mul(value).toInt256Safe();\n    magnifiedDividendCorrections[from] = magnifiedDividendCorrections[from].add(\n      _magCorrection\n    );\n    magnifiedDividendCorrections[to] = magnifiedDividendCorrections[to].sub(\n      _magCorrection\n    );\n  }\n\n  function _mint(address account, uint256 value) internal override {\n    super._mint(account, value);\n\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[\n      account\n    ].sub((magnifiedDividendPerShare.mul(value)).toInt256Safe());\n  }\n\n  function _burn(address account, uint256 value) internal override {\n    super._burn(account, value);\n\n    magnifiedDividendCorrections[account] = magnifiedDividendCorrections[\n      account\n    ].add((magnifiedDividendPerShare.mul(value)).toInt256Safe());\n  }\n\n  function _setBalance(address account, uint256 newBalance) internal {\n    uint256 currentBalance = balanceOf(account);\n\n    if (newBalance > currentBalance) {\n      uint256 mintAmount = newBalance.sub(currentBalance);\n      _mint(account, mintAmount);\n    } else if (newBalance < currentBalance) {\n      uint256 burnAmount = currentBalance.sub(newBalance);\n      _burn(account, burnAmount);\n    }\n  }\n}\n"
    },
    "contracts/IterableMapping/IterableMapping.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nlibrary IterableMapping {\n  // Iterable mapping from address to uint;\n  struct Map {\n    address[] keys;\n    mapping(address => uint256) values;\n    mapping(address => uint256) indexOf;\n    mapping(address => bool) inserted;\n  }\n\n  function get(Map storage map, address key) internal view returns (uint256) {\n    return map.values[key];\n  }\n\n  function getIndexOfKey(Map storage map, address key)\n    internal\n    view\n    returns (int256)\n  {\n    if (!map.inserted[key]) {\n      return -1;\n    }\n    return int256(map.indexOf[key]);\n  }\n\n  function getKeyAtIndex(Map storage map, uint256 index)\n    internal\n    view\n    returns (address)\n  {\n    return map.keys[index];\n  }\n\n  function size(Map storage map) internal view returns (uint256) {\n    return map.keys.length;\n  }\n\n  function set(\n    Map storage map,\n    address key,\n    uint256 val\n  ) internal {\n    if (map.inserted[key]) {\n      map.values[key] = val;\n    } else {\n      map.inserted[key] = true;\n      map.values[key] = val;\n      map.indexOf[key] = map.keys.length;\n      map.keys.push(key);\n    }\n  }\n\n  function remove(Map storage map, address key) internal {\n    if (!map.inserted[key]) {\n      return;\n    }\n\n    delete map.inserted[key];\n    delete map.values[key];\n\n    uint256 index = map.indexOf[key];\n    uint256 lastIndex = map.keys.length - 1;\n    address lastKey = map.keys[lastIndex];\n\n    map.indexOf[lastKey] = index;\n    delete map.indexOf[key];\n\n    map.keys[index] = lastKey;\n    map.keys.pop();\n  }\n}\n"
    },
    "contracts/DividendPayingToken/IDividendPayingToken.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IDividendPayingToken {\n  function dividendOf(address _owner) external view returns (uint256);\n\n  function withdrawDividend() external;\n\n  event DividendsDistributed(address indexed from, uint256 weiAmount);\n\n  event DividendWithdrawn(address indexed to, uint256 weiAmount);\n}\n"
    },
    "contracts/DividendPayingToken/IDividendPayingTokenOptional.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\ninterface IDividendPayingTokenOptional {\n  function withdrawableDividendOf(address _owner)\n    external\n    view\n    returns (uint256);\n\n  function withdrawnDividendOf(address _owner) external view returns (uint256);\n\n  function accumulativeDividendOf(address _owner)\n    external\n    view\n    returns (uint256);\n}\n"
    },
    "contracts/math/SafeMathInt.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nlibrary SafeMathInt {\n  function mul(int256 a, int256 b) internal pure returns (int256) {\n    // Prevent overflow when multiplying INT256_MIN with -1\n    // https://github.com/RequestNetwork/requestNetwork/issues/43\n    require(!(a == -2**255 && b == -1) && !(b == -2**255 && a == -1));\n\n    int256 c = a * b;\n    require((b == 0) || (c / b == a));\n    return c;\n  }\n\n  function div(int256 a, int256 b) internal pure returns (int256) {\n    // Prevent overflow when dividing INT256_MIN by -1\n    // https://github.com/RequestNetwork/requestNetwork/issues/43\n    require(!(a == -2**255 && b == -1) && (b > 0));\n\n    return a / b;\n  }\n\n  function sub(int256 a, int256 b) internal pure returns (int256) {\n    require((b >= 0 && a - b <= a) || (b < 0 && a - b > a));\n\n    return a - b;\n  }\n\n  function add(int256 a, int256 b) internal pure returns (int256) {\n    int256 c = a + b;\n    require((b >= 0 && c >= a) || (b < 0 && c < a));\n    return c;\n  }\n\n  function toUint256Safe(int256 a) internal pure returns (uint256) {\n    require(a >= 0);\n    return uint256(a);\n  }\n}\n"
    },
    "contracts/math/SafeMathUint.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nlibrary SafeMathUint {\n  function toInt256Safe(uint256 a) internal pure returns (int256) {\n    int256 b = int256(a);\n    require(b >= 0);\n    return b;\n  }\n}\n"
    },
    "contracts/test/WBNBMock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../utils/Context.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../math/SafeMath.sol\";\n\ncontract WBNBMock is Context, IERC20 {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = 9;\n  }\n\n  function name() public view virtual returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view virtual returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view virtual returns (uint8) {\n    return 9;\n  }\n\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function _mint(address account, uint256 amount) public virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _setupDecimals(uint8 decimals_) internal virtual {\n    _decimals = decimals_;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    },
    "contracts/test/ERC20Mock.sol": {
      "content": "//SPDX-License-Identifier: MIT\n\npragma solidity 0.8.15;\n\nimport \"../utils/Context.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../math/SafeMath.sol\";\n\ncontract ERC20Mock is Context, IERC20 {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n  uint8 private _decimals;\n\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n    _decimals = 9;\n  }\n\n  function name() public view virtual returns (string memory) {\n    return _name;\n  }\n\n  function symbol() public view virtual returns (string memory) {\n    return _symbol;\n  }\n\n  function decimals() public view virtual returns (uint8) {\n    return 9;\n  }\n\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  function balanceOf(address account)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _balances[account];\n  }\n\n  function transfer(address recipient, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _transfer(_msgSender(), recipient, amount);\n    return true;\n  }\n\n  function allowance(address owner, address spender)\n    public\n    view\n    virtual\n    override\n    returns (uint256)\n  {\n    return _allowances[owner][spender];\n  }\n\n  function approve(address spender, uint256 amount)\n    public\n    virtual\n    override\n    returns (bool)\n  {\n    _approve(_msgSender(), spender, amount);\n    return true;\n  }\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    _transfer(sender, recipient, amount);\n    _approve(\n      sender,\n      _msgSender(),\n      _allowances[sender][_msgSender()].sub(\n        amount,\n        \"ERC20: transfer amount exceeds allowance\"\n      )\n    );\n    return true;\n  }\n\n  function increaseAllowance(address spender, uint256 addedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].add(addedValue)\n    );\n    return true;\n  }\n\n  function decreaseAllowance(address spender, uint256 subtractedValue)\n    public\n    virtual\n    returns (bool)\n  {\n    _approve(\n      _msgSender(),\n      spender,\n      _allowances[_msgSender()][spender].sub(\n        subtractedValue,\n        \"ERC20: decreased allowance below zero\"\n      )\n    );\n    return true;\n  }\n\n  function _transfer(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(\n      amount,\n      \"ERC20: transfer amount exceeds balance\"\n    );\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n  }\n\n  function mint(address account, uint256 amount) public virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    _balances[account] = _balances[account].sub(\n      amount,\n      \"ERC20: burn amount exceeds balance\"\n    );\n    _totalSupply = _totalSupply.sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  function _setupDecimals(uint8 decimals_) internal virtual {\n    _decimals = decimals_;\n  }\n\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}